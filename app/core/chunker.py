import json
from typing import Dict, Any, List
from langchain_core.documents import Document
from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter

class AuraChunker:
    """
    Handles the chunking of AuraQuery articles into two layers:
    Index A: Abstract (single document)
    Index B: Body (markdown-header semantic chunks + fallback token overlapping)
    """

    def __init__(self, max_chunk_size: int = 1000, chunk_overlap: int = 200):
        # We split on markdown headers ## and ### as requested
        self.headers_to_split_on = [
            ("##", "Header 2"),
            ("###", "Header 3"),
        ]
        
        # Instantiate the semantic markdown splitter
        self.markdown_splitter = MarkdownHeaderTextSplitter(
            headers_to_split_on=self.headers_to_split_on
        )
        
        # Instantiate the fallback text splitter
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=max_chunk_size,
            chunk_overlap=chunk_overlap,
            # We add separators to try to split cleanly on paragraphs or sentences first
            separators=["\n\n", "\n", ".", " ", ""],
        )

    def process_article(self, article_data: Dict[str, Any]) -> Dict[str, List[Document]]:
        """
        Process the raw JSON article data and return a dictionary with the chunks 
        for Index A (Abstract) and Index B (Body).
        """
        abstract_layer = article_data.get("abstract_layer", {})
        body_layer = article_data.get("body_layer", {})

        # Extract common article-level metadata to append to all chunks
        # Instead of hardcoding keys, we'll take all keys from abstract_layer/body_layer 
        # (excluding the 'content' field and making sure we don't duplicate).
        article_metadata = {k: v for k, v in article_data.items() if k not in ["abstract_layer", "body_layer", "content"]}
        
        # Combine metadata from abstract_layer as the source of truth for structural article metadata
        for k, v in abstract_layer.items():
            if k not in ["content", "section"]:
                article_metadata[k] = v

        # Combine any missing metadata from body_layer
        for k, v in body_layer.items():
            if k not in ["content", "section"] and k not in article_metadata:
                article_metadata[k] = v

        # -------------------------------------------------------------
        # Index A: Abstract Layer (No splitting, single document)
        # -------------------------------------------------------------
        index_a_docs = []
        if abstract_layer and "content" in abstract_layer:
            abstract_meta = article_metadata.copy()
            abstract_meta["section"] = "abstract"
            
            abstract_content = abstract_layer["content"]
            
            abstract_doc = Document(
                page_content=abstract_content,
                metadata=abstract_meta
            )
            index_a_docs.append(abstract_doc)

        # -------------------------------------------------------------
        # Index B: Body Layer (Markdown splitting + length fallback)
        # -------------------------------------------------------------
        index_b_docs = []
        if body_layer and "content" in body_layer:
            body_content = body_layer["content"]
            
            # Pass 1: Semantic chunking by markdown headers
            semantic_chunks = self.markdown_splitter.split_text(body_content)
            
            # Pass 2: Fallback length chunking
            final_chunks = self.text_splitter.split_documents(semantic_chunks)
            
            # Enrich chunks with article metadata
            for doc in final_chunks:
                # Merge the markdown header metadata generated by the splitter 
                # with the general article metadata.
                merged_meta = article_metadata.copy()
                merged_meta.update(doc.metadata)  # Keep the header info
                merged_meta["section"] = "body"
                doc.metadata = merged_meta
                
                index_b_docs.append(doc)

        return {
            "index_a": index_a_docs,
            "index_b": index_b_docs
        }
